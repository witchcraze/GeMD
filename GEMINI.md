# GEMINI.md: AI駆動開発のための指示書

このドキュメントは、AIアシスタント（Gemini）がGeMDプロジェクトにおいて開発タスクを遂行するための指示書です。一貫性、品質、効率性を担保するため、以下のガイドラインに厳密に従ってください。

## 1. 本ドキュメント(GEMINI.md)の運用指針

### 1.1. 目的
このドキュメントは、AIが自律的に開発を進めるための「思考と行動の起点」です。AIへの指示はすべてここに集約され、プロジェクトの憲法として機能します。

### 1.2. 構成と記述ルール
本ドキュメントの肥大化を防ぎ、可読性とメンテナンス性を維持するため、以下のルールに従って記述します。

*   **戦略とワークフローの明確な分離:**
    *   **戦略セクション (3章):** プロジェクトが **「何を (What)」** 目指し、 **「なぜ (Why)」** そうするのかという **方針** のみを記述します。長期的で普遍的な指針が対象です。
    *   **ワークフローセクション (4章):** 戦略を実現するために **「どのように (How)」** 作業するのかという、**具体的で再現可能な手順** のみを記述します。AIが直接実行・参照するコマンドや規約が対象です。
*   **詳細の外部化:**
    *   特定の技術に関する詳細なセットアップ手順、設計思想、長文の規約などは、`docs/`ディレクトリ配下に別のMarkdownファイルとして作成します。
    *   本ドキュメントには、その外部ファイルへの参照（リンク）を記述するに留め、本文書はAIの行動を規定する「指示」に特化させます。

### 1.3. 更新プロセス
本ドキュメントの変更は、品質を維持し、意図しない変更を防ぐため、以下のプロセスを必須とします。
1.  GitHub Issueで変更を提案します。
2.  提案が承認された後、AIがこのドキュメントを更新するPull Requestを作成します。
3.  Pull Requestがレビューされ、マージされることで変更が確定します。

### 1.4. 記述スタイルガイド
本ドキュメントの可読性を維持するため、以下の記述スタイルに従います。

*   **箇条書き（リスト）の使用:**
    *   **目的:** 手順、チェックリスト、並列な選択肢など、順序や階層を持つ情報を記述する場合に使用します。
    *   **例:** 開発プロセスのステップ、セルフレビューの観点。

*   **表（テーブル）の使用:**
    *   **目的:** 複数の項目を、共通の属性で比較・対照する場合に使用します。情報の対応関係を明確に示したい場合に最適です。
    *   **例:** ラベル一覧とそれぞれの役割、コマンドのオプションと説明。

*   **文体:** AIへの指示であることが明確になるよう、敬体（です・ます調）ではなく、常体（だ・である調）または命令形で記述します。

---

## 2. AI連携における基本原則
*   **目的志向:** Issueに書かれた表面的な指示だけでなく、その背後にあるユーザーの最終的な目的を理解し、目標達成のために能動的に行動してください。
*   **規約の遵守:** 本リポジトリで定められたコーディングスタイル、テストフレームワーク、アーキテクチャパターンに厳密に従ってください。
*   **透明性の確保:** ファイル変更やコマンド実行など、AIが行った操作はすべて明確に記録・報告してください。
*   **段階的な実行:** 大きな変更は小さなステップに分割し、重要な判断が必要な場面では必ずユーザーに確認を求めて���ださい。

## 3. プロジェクト戦略
*(このセクションでは、プロジェクトが目指す「方針」のみを記述します)*

*   **開発戦略:** 
    *   **Issue駆動開発 (IDD) の徹底:** すべての開発タスクはGitHub Issueを起点とします。Issueで目的、仕様、計画を明確に合意形成してから実装に着手することで、手戻りを防ぎ、透明性を確保します。
    *   **テスト駆動開発 (TDD) の採用:** 新機能追加やリファクタリングの際は、まずテストケースを定義し、そのテストをパスする形で実装を進めることを原則とします。これにより、コードの品質と保守性を最優先します。
    *   **ドキュメントの重視:** コードの変更とドキュメントの更新を一体のタスクとして扱い、常に最新の状態を保ちます。
*   **GitHub運用戦略:**
    *   **基本戦略: GitHub Flowの採用:** `main`ブランチを常にデプロイ可能な状態に保ち、機能追加や修正はすべてフィーチャーブランチで行う「GitHub Flow」を基本戦略とします。
    *   **採用理由:** この戦略は、運用ルールがシンプルで、AIがタスクを遂行する上でコンテキストの消費を抑え、セッションが中断された場合でも状態の把握が容易であるためです。複数の永続的なブランチ（例: `develop`）を管理する複雑さを回避し、AIが一貫性を保ち、安定して動作することを最優先します。
    - **ブランチ戦略:**
        - `main`ブランチ: 本番環境にデプロイされる、最も安定したブランチです。直接のコミットは禁止し、Pull Requestのマージによってのみ更新されます。
        - フィーチャーブランチ: 各Issueに対応するブランチです。`main`ブランチから作成し、作業完了後に`main`ブランチへのPull Requestを作成します。
    - **ブランチのライフサイクル:**
        - **作成:** Issueの実装に着手するタイミングで、`main`ブランチから作成します。
        - **命名規則:** `4.2. Issue駆動開発プロセス`で定義された `{issue番号}-{issueのタイトルをケバブケースにしたもの}` に従います。
        - **削除:** Pull Requestが`main`ブランチにマージされた後、速やかに削除します。

## 4. 開発ワークフロー
*(このセクションでは、戦略を実行するための「具体的で再現可能な手順」のみを記述します。AIはこのワークフローに厳密に従って、自律的に開発を遂行します)*

### 4.1. 基本原則：シングルタスクの徹底
AIは、複数のIssueを同時に処理しません。必ず一つのIssueが完了（マージ）してから、次のIssueに着手します。これにより、ブランチのコンフリクトや作業の混乱を防ぎます。

### 4.2. Issue駆動開発プロセス
以下は、一つのIssueが起票されてからクローズされるまでの一連のプロセスです。AIとユーザーはこのプロセスに従って連携します。

#### **ステップ1: Issueの受付と担当設定**
1.  **トリガー:** ユーザーまたはAIが新しいIssueを作成します。
2.  **AIの対応:**
    *   AIは新しく作成されたIssueを検知し、自身をそのIssueの担当者（Assignee）として設定します。
    *   Issueの内容を分析し、`4.4. ラベル管理`で定義された**状態ラベル**と**種別ラベル**の中から、最も適切と思われるラベルを付与します。
        *   **状態ラベル:** `status: planning`
        *   **種別ラベル:** `type: feature` や `type: bug` などから1つを選択

#### **ステップ2: 実装計画の策定と合意形成**
1.  **トリガー:** Issueに `status: planning` ラベルが付与される。
2.  **AIの対応:**
    *   Issueの内容、関連コメント、リンク先のドキュメントを精読し、表面的な要求だけでなく、その背後にある**目的**と**解決すべき根本的な課題**を完全に理解します。
    *   目的が不明確、または複数の解釈が可能な場合は、ユーザーに質問を投げかけ、意図を明確化します。
    *   複数の実装アプローチが考えられる場合は、それぞれのメリット・デメリットを簡潔に提示し、ユーザーに最適な選択を促します。
    *   上記の分析に基づき、実装や仕様変更に伴って更新が必要なドキュメントとコードを特定します。
    *   実現に必要なタスク（コード変更、ドキュメント更新など）を分解し、変更予定のファイルをすべてリストアップした、具体的な実装計画を立てます。
    *   以下のフォーマットで、実装計画をIssueにコメントします。その際、本文の長短に関わらず、必ず一時ファイルを作成し`--body-file`オプションを使用します。
        ```markdown
        ### 実装計画のご提案

        このIssueを解決するため、以下の計画で実装を進めます。

        **変更対象ファイル:**
        - `docs/01_ARCHITECTURE.md`
        - `src/core/main.py`
        - `tests/test_main.py`

        #### 1. **(ドキュメント更新の概要)**
        - `docs/01_ARCHITECTURE.md`: (更新内容の要約)

        #### 2. **(コード変更の概要)**
        - `src/core/main.py`: (具体的な作業内容 a)
        - `tests/test_main.py`: (具体的な作業内容 b)

        ---
        ご承認いただける場合は、このコメントに「承認」と返信してください。
        ```
3.  **ユーザーの対応:**
    *   計画をレビューし、問題がなければ「承認」とコメントします。修正が必要な場合は、具体的な修正点を指示します。

#### **ステップ3: 実装とPull Requestの作成**
1.  **トリガー:** ユーザーが実装計画を「承認」する。
2.  **AIの対応:**
    *   Issueの `status: planning` ラベルを削除し、`status: implementing` ラベルを付与します。
    *   `main` ブランチから、`{issue番号}-{issueのタイトルをケバブケースにしたもの}` という命名規則で新しいブランチを作成します。
        *   例: `12-update-development-workflow`
    *   実装計画に沿って、コードの変更、ファイルの作成・編集、テストの追加などを行います。
        *   **【重要】計画外のファイル変更の原則禁止:** AIは、実装計画で合意されたファイル以外は原則として変更しません。もし実装の過程で、計画外のファイル変更が必要だと判断した場合は、作業を中断し、その理由と変更内容をユーザーに報告し、承認を求めます。
    *   作業が完了したら、変更内容をコミットします。コミットメッセージは [Conventional Commits](https://www.conventionalcommits.org/) の規約に従います。
    *   `main` ブランチをターゲットにしたPull Requestを作成します。
    *   PRの本文には、関連するIssueへのリンク（例: `Closes #12`）を必ず含めます。

#### **ステップ4: セルフレビュー、自己修正、そしてレビュー依頼**
1.  **トリガー:** Pull Requestが作成される。
2.  **AIの対応:**
    *   Issueの `status: implementing` ラベルを削除し、`status: review` ラベルを付与します。
    *   **差分確認:** AIは `gh pr diff` コマンドを実行し、自身の変更内容が意図通りであることを確認します。
    *   **セルフレビューの実施:** 以下の観点でセルフレビューを実施します。
        1.  **差分は意図通りか？:** `gh pr diff` の結果と実装計画を照合します。
        2.  **実装はIssueの要求を満たしているか？**
        3.  **`GEMINI.md`の規約（テスト、命名規則など）を遵守しているか？**
        4.  **コードは十分に読みやすく、保守性が高いか？**
        5.  **変更による潜在的な副作用はないか？**
        6.  **計画外のファイル変更はないか？**
        7.  **コード変更に伴うドキュメント更新は適切か？**
    *   **自己修正:**
        *   セルフレビューで問題を検知した場合、AIはまず自己修正を試みます。ローカルでコードを修正し、`git commit --amend` でコミットを修正後、`git push --force` でリモートブランチを更新します。
        *   修正後、再度このステップの最初（差分確認）からプロセスをやり直します。
        *   AI自身での修正が困難な場合に限り、ユーザーにメンションし、具体的な問題点と解決策の相談をPRのコメントで行います。
    *   **レビュー依頼:** 自己修正が不要、または完了した場合、以下のフォーマットでセルフレビューの結果をPRにコメントし、ユーザーにレビューを依頼します。その際、本文の長短に関わらず、必ず一時ファイルを作成し`--body-file`オプションを使用します。
        ```markdown
        ### セルフレビュー報告

        以下の観点でセルフレビューを実施し、問題がないことを確認しました。

        - **[観点1] 差分は意図通りか？**
          - (確認結果と自己評価)
        - **[観点2] 実装はIssueの要求を満たしているか？**
          - (確認結果と自己評価)
        - **[観点3] `GEMINI.md`の規約（テスト、命名規則など）を遵守しているか？**
          - (確認結果と自己評価)
        - **[観点4] コードは十分に読みやすく、保守性が高いか？**
          - (確認結果と自己評価)
        - **[観点5] 変更による潜在的な副作用はないか？**
          - (確認結果と自己評価)
        - **[観点6] 計画外のファイル変更はないか？**
          - (確認結果と自己評価)
        - **[観点7] コード変更に伴うドキュメント更新は適切か？**
          - (確認結果と自己評価)

        ---
        ご確認の上、マージのご承認をお願いいたします。
        ```
3.  **ユーザーの対応:**
    *   PRの内容とAIのセルフレビューをレビューします。
    *   問題がなければ、PRに対して「マージを承認します」とコメントします。修正が必要な場合は、具体的な修正点をコメントします。

#### **ステップ5: マージとクリーンアップ**
1.  **トリガー:** ユーザーがPull Requestに「マージを承認します」とコメントする。
2.  **AIの対応:**
    *   Pull Requestをマージします。
    *   作業ブランチを削除します。
    *   関連するIssueが自動でクローズされたことを確認します。（PRの `Closes #12` により自動化）
    *   クローズされたIssueの `status: review` ラベルを削除し、`status: done` ラベルを付与します。

### 4.3. テストワークフロー
*   **テストの目的:** AIが生成するコードの品質を保証し、リファクタリングや機能追加に対する安全性を確保することを目的とします。
*   **テストの種類:**
    *   **単体テスト:** 個々の機能やモジュールが期待通りに動作することを検証します。
    *   **結合テスト:** 複数のモジュールを組み合わせた際に、連携が正しく行われることを検証します。
    *   **パフォーマンステスト:** 必要に応じて、システムの性能要件（応答時間、スループットなど）を測定するためのテストを実装します。
*   **テストカバレッジ:** 主要な機能やロジックについては、高いテストカバレッジを目指しますが、カバレッジの数値自体を目的とはしません。重要なのは、ビジネスロジックの核心部分が十分にテストされていることです。
*   **テスト実行:**
    *   **ローカルでの実行:** AIはコード変更後、関連するテストを実行し、すべてのテストがパスすることを確認してからPull Requestを作成します。
    *   **CIでの実行（推奨）:** Pull Requestが作成・更新されるたびに、すべてのテストが自動的に実行される体制を推奨します。CI環境が利用可能な場合、AIは積極的にその設定と活用を試みます。

### 4.4. ラベル管理
AIは、IssueやPull Requestの状況と種類を明確にするため、以下のラベルを使用します。
AIは、ラベルを付与する際に該当のラベルが存在しない場合、以下の定義に従って自動でラベルを作成した上で付与します。

#### **状態ラベル (Status)**
IssueやPRが現在どの開発段階にあるかを示します。

| ラベル名 | 色 | 説明 |
| :--- | :--- | :--- |
| `status: planning` | `#FBCA04` | AIが実装計画を策定中の状態 |
| `status: implementing` | `#1D76DB` | AIが実装作業中の状態 |
| `status: review` | `#8E44AD` | Pull Requestがレビュー待ちの状態 |
| `status: done` | `#0E8A16` | Issueの対応が完了し、マージ済みの状態 |

#### **種別ラベル (Type)**
IssueやPRがどのような種類のタスクであるかを示します。

| ラベル名 | 色 | 説明 |
| :--- | :--- | :--- |
| `type: bug` | `#D73A4A` | 既存機能の不具合 |
| `type: feature` | `#0E8A16` | 新しい機能の追加 |
| `type: documentation` | `#0075CA` | ドキュメントの作成・更新 |
| `type: refactor` | `#A2EEEF` | 外部的な振る舞いを変更しないコード改善 |
| `type: chore` | `#FFFFFF` | ビルドプロセスや補助ツールの変更など、上記以外のタスク |

## 5. ドキュメント管理ワークフロー
AIがプロジェクトの仕様や設計思想を正確に理解し、開発とドキュメントの整合性を維持するためのワークフローを定義します。

### 5.1. ドキュメントの構成
プロジェクトに関する情報は、`docs/`ディレクトリ配下に以下のファイル群で管理します。AIは開発に着手する前に、必ずこれらのドキュメントに目を通し、内容を理解します。

| ファイル名 | 目的 |
| :--- | :--- |
| `00_PROJECT_OVERVIEW.md` | プロジェクトの全体像と目的を定義する |
| `01_ARCHITECTURE.md` | システムの構造や設計思想を定義する |
| `02_CODING_STANDARDS.md` | コードの一貫性を保つための規約を定義する |
| `03_TESTING_GUIDELINES.md` | 品質を保証するためのテスト方針と手順を定義する |
| `04_SETUP.md` | 開発環境の構築手順を定義する |

### 5.2. ドキュメントの更新プロセス
*   **タイミング:** Issueに対応する実装や仕様変更によって、上記のドキュメントの内容に影響が出る場合に更新します。
*   **手順:**
    1.  AIは、`ステップ2: 実装計画の策定と合意形成`の段階で、更新が必要なドキュメントを特定し、その更新内容を実装計画に含めます。
    2.  ユーザーの承認後、AIはコードの変更と合わせてドキュメントの更新も行います。
*   **`README.md`の管理:** `README.md`はプロジェクトの顔であるため、特に重要な更新があった場合に、他のドキュメント更新と同様のプロセスで更新します。